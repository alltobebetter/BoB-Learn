# 装饰器：给你的函数穿上华丽的外衣

想象一下，你有一个很简单的函数，它只负责做一件事情，比如煎鸡蛋：

```python
def 煎鸡蛋():
  print("滋滋滋...鸡蛋煎好了！")
```

现在，你想在煎鸡蛋之前和之后都做一些额外的事情，比如：

* **煎之前:**  先热锅，倒油
* **煎之后:**  撒点盐，装盘

你可以直接修改 `煎鸡蛋` 函数，把这些步骤都加进去。但这样一来，`煎鸡蛋` 函数就变得很复杂了，而且如果你以后还想添加别的步骤（比如加点胡椒粉），还得继续修改它。

**装饰器就是为了解决这个问题而诞生的！**

**装饰器就像给你的函数穿上华丽的外衣，它可以在不改变函数本身代码的情况下，给函数添加额外的功能。**

**还是用煎鸡蛋的例子来说明：**

```python
def 加热倒油(func):  # 这就是装饰器，它接收一个函数作为参数
  def wrapper():  # 定义一个新的函数，用来包装原来的函数
    print("加热锅...")
    print("倒油...")
    func()  # 调用原来的函数
    print("撒盐...")
    print("装盘...")
  return wrapper  # 返回新的函数


@加热倒油  # 使用 @ 符号把装饰器应用到煎鸡蛋函数上
def 煎鸡蛋():
  print("滋滋滋...鸡蛋煎好了！")


煎鸡蛋()  # 调用煎鸡蛋函数，实际上执行的是 wrapper 函数
```

**输出:**

```
加热锅...
倒油...
滋滋滋...鸡蛋煎好了！
撒盐...
装盘...
```

**解释：**

1. `加热倒油` 函数是一个装饰器，它接收一个函数 `func` 作为参数。
2. 在 `加热倒油` 函数内部，定义了一个新的函数 `wrapper`，这个函数会先执行加热倒油的操作，然后调用 `func` 函数（也就是原来的煎鸡蛋函数），最后执行撒盐装盘的操作。
3. `@加热倒油`  表示把 `加热倒油` 装饰器应用到 `煎鸡蛋` 函数上。
4. 当我们调用 `煎鸡蛋()` 时，实际上执行的是 `wrapper` 函数，它包含了煎鸡蛋前后的额外操作。

**这样一来，我们就把煎鸡蛋前后的操作都封装到了装饰器里，`煎鸡蛋` 函数本身的代码保持简洁，而且以后想添加别的步骤，只需要修改装饰器就可以了，非常方便！**

**总结:**

* 装饰器可以给函数添加额外的功能，而不用修改函数本身的代码。
* 装饰器本质上是一个接收函数作为参数并返回新函数的高阶函数。
* 使用 `@` 符号可以方便地将装饰器应用到函数上。

希望这个通俗易懂的解释能帮助你理解装饰器！
